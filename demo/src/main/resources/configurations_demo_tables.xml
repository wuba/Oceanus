<configurations>
	<!--  
		bean 标签声明一个实体，实现类必须有无参的构造函数
			属性：id（必填）为该实体命名
			属性：class（必填）实现类全名
	-->
	<bean id="userShardFunc" class="com.bj58.oceanus.demo.shard.UserShardFunction" />
	
	<!--  
		table 标签定义逻辑表映射，由oceanus解析到的表名，映射并重写，路由到分库环境中运行
			属性：name（必填）声明table名字，当命中sql中的table name时，就会按照配置的逻辑进行路由
			属性：differ-name（必填）sql中的表名是否与DB中的一致，是否需要重写
			属性：shard-type（必填）分库分表类型。BY-DATABASE 表示按数据库进行划分。 BY-TABLE 表示按表划分。 BY-DATABASE-TABLE 表示按库和表划分。 NO-SHARD 表示不分库分表
			属性：threadpool （必填）为该table指定使用哪个线程池进行异步操作
			子节点：columns 内部填充column列表
				子节点：column 指定用于sharding逻辑的字段
					属性：name（必填）约定用于sharding逻辑字段的名称，当sql解析出对应的字段后，调用其指定的sharding函数的execute方法
			子节点：namenodes 内部填充namenode列表
				子节点：namenode 
					属性：ref （必填）指向namenode id
					属性：tablename （选填）当differ-name是true的时候，会使用这里的tablename进行sql重写
			子节点：function 指定该table的shading函数，要求excute方法返回namenode列表的下标，从0开始
				属性：ref （必填）指向sharding函数 id
			
	-->
	<table name="t_user" differ-name="true" shard-type="BY_TABLE" threadpool="default">
		<columns>
			<column name="id"/>
		</columns>
		<namenodes>
			<namenode ref="user_source1" tablename="t_user1"/>
			<namenode ref="user_source1" tablename="t_user2"/>
		</namenodes>
		
		<function ref="userShardFunc" />
	</table>
	
	<table name="t_product" differ-name="true" shard-type="BY_TABLE" threadpool="default">
		<columns>
			<column name="id"/>
		</columns>
		<namenodes>
			<namenode ref="product_source1" tablename="test_oceanus_schema0.t_product"/>
			<namenode ref="product_source1" tablename="test_oceanus_schema1.t_product"/>
			<namenode ref="product_source2" tablename="test_oceanus_schema2.t_product"/>
			<namenode ref="product_source2" tablename="test_oceanus_schema3.t_product"/>
		</namenodes>
		
		<function ref="userShardFunc" />
	</table>
 
 
</configurations>